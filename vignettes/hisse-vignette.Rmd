---
title: "Running HiSSE"
author: "Jeremy M. Beaulieu"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Running HiSSE}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---



This tutorial gives a basic introduction on how to set up and execute a model using [hisse](http://cran.r-project.org/web/packages/hisse/) (Beaulieu & O'Meara 2015). While hidden state speciation and extinction model (HiSSE) is a natural extension of the models contained within [diversitree](http://cran.r-project.org/web/packages/diversitree/) (FitzJohn 2012), our implementation has a very different set up. 

Before getting started, first load the hisse package:
```{r, eval=TRUE}
library(hisse)
```
Also be sure to load diversitree. We will be using it to generate a test dataset that should also help reinforce the idea behind a "hidden" state.
```{r, eval=TRUE}
library(diversitree)
set.seed(4)
# Essentially we are setting up a model that models the evolution of two binary characters
# Thus, we are assuming the following state combinations 1=00, 2=10, 3=01, 4=11:
pars <- c(0.1,0.1,0.1,0.2, rep(0.03, 4), 0.01,0.01,0, 0.01, 0, 0.01, 0.01,0,0.01, 0,0.01,0.01)
phy <- tree.musse(pars, max.taxa=50, x0=1, include.extinct=FALSE)
sim.dat <- data.frame(names(phy$tip.state), phy$tip.state)
# Now we want to make the states associated with the second character hidden from us. So, 
# we remove states 3 and 4 and make them 1 and 2
sim.dat[sim.dat[,2]==3,2] = 1
sim.dat[sim.dat[,2]==4,2] = 2
# This next step simply forces the character to be binary:
sim.dat[,2] = sim.dat[,2] - 1
```
In the end you have a single binary character. But, this character clearly evolved under a much more complex process. It is this complexity that HiSSE is trying estimate.

##Specifying the diversification parameters
Rather than optimizing $\lambda_i$ and $\mu_i$ separately, hisse optimizes transformations of these variables. Here we let $\tau_i = \lambda_i+\mu_i$ define “net turnover”, and we let $\epsilon_i = \mu_i / \lambda_i$ define the "extinction fraction". This reparameterization alleviates problems associated with over-fitting when $\lambda_i$ and $\mu_i$ are highly correlated, but both matter in explaining the diversity pattern. The number of free parameters in the model for both net turnover and extinction fraction are specified as index vectors provided to the function call. Each vector contains four entries, and correspond to rates associated with the observed states (0 or 1) and the hidden states (A or B). They are ordered as follows: 0A, 1A, 0B, 1B. The index vector not only specifies the number of free parameters, but it can also be set up such that parameters are linked among states or even dropped from the model entirely. 

Let's walk through a couple of examples. Take, for instance, the following index vectors:
```{r, eval=TRUE}
turnover.anc = c(1,1,0,0)
eps.anc = c(1,1,0,0)
```
For turnover.anc, there is a single free parameter for both 0A and 1A state combinations; there is a single free parameter for extinction fraction. This is, of course, equivalent to a BiSSE model with a fixed turnover and extinction rates across the observed states 0 an 1. Now, say we want to include separate turnover rates for both states: 
```{r, eval=TRUE}
turnover.anc = c(1,2,0,0)
```
A full hisse model would thus be,
```{r, eval=TRUE}
turnover.anc = c(1,2,3,4)
```
which corresponds to four separate net turnover rates. Extinction fraction, needless to say, follows the same format, though including a zero for a state we want to include in the model corresponds to no extinction, which is the Yule equivalent:
```{r, eval=TRUE}
eps.anc = c(0,0,0,0)
```
Fairly straightforward, but why do we do it this way? Well, this particular format makes it easier to generate a large set of nested models to test. 

##Setting up the transition rate matrix
The transition rate matrix is set up separate from the diversification rate parameters. This was intentional. We want to reinforce the idea that SSE models are not trait evolution models, but rather joint models for the tree and the evolution of a trait. It for this reason that we depict the transition rates in the usual **Q** matrix format.

To generate the index matrix describing the free parameters in the transition model, we use the `TransMatMaker()` function:
```{r, eval=TRUE}
trans.rates = TransMatMaker(hidden.states=TRUE)
trans.rates
```
Note that the default contains 12 free parameters, which includes dual transitions between both the observed trait and the hidden trait (e.g., q0A<->q1B). Personally, I'm skeptical about such transitions and always remove them from the model entirely. In any event, they can actually be dropped using the internal function `ParDrop()`:
```{r, eval=TRUE}
trans.rates.nodual = ParDrop(trans.rates, c(3,5,8,10))
trans.rates.nodual
```
You may also want to run a model where we assume all transitions are equal to one another. This will often make sense because it is often difficult to reasonably estimate the transition rates (see Beaulieu and O'Meara 2015). To set the rates equal we can use another internal function, `ParEqual()`. This function takes pairs of indexes and sets the two equal based on the index of the first entry. Take our example above and let's set parameter 1 and 6 to have the same rate:
```{r, eval=TRUE}
trans.rates.nodual.equal16 = ParEqual(trans.rates.nodual, c(1,6))
trans.rates.nodual.equal16
```
Note that the index for parameter 6 has become 1 -- in other words, their rate will take the same value. Now, let's set all rates to be equal using this function:
```{r, eval=TRUE}
trans.rates.nodual.allequal = ParEqual(trans.rates.nodual, c(1,2,1,3,1,4,1,5,1,6,1,7,1,8))
trans.rates.nodual.allequal
```
To run the equivalent to a BiSSE model implemented in diversitree, the matrix set up would look like this:
```{r, eval=TRUE}
trans.rates.bisse = TransMatMaker(hidden.states=FALSE)
trans.rates.nodual.allequal
```
Whatever transition matrix is designed, it is supplied to the `trans.rate=` argument in the hisse call.

##Setting up the null-two model
Recently Rabosky and Goldberg (2015) raised an important concern with SSE models. They showed rather convincingly that if the tree is evolving under a heterogeneous branching structure that is completely independent from the evolution of a character, BiSSE will almost always return high support for a model of trait-dependent diversfication. From an interpretational stand point, this is troubling. However, it is important to bear in mind what such a result is really saying: Yes, BiSSE is very wrong in assigning rate differences to a neutral trait, but a simple equal rates diversification model is not correct either. 

So what to do? Well, in our view, the larger issue here is the use of a rather trivial null model (i.e., equal rates diversification) to compare against the fit of BiSSE. With any realistically complex tree, a simple model and one with even slightly more complexity will very likely yield strong support for the latter. Again, it is important to stress that SSE models are not models of trait evolution, but rather joint models for the tree and the trait. So, a fairer comparison would need to involve some sort of null model that contains the same degree of complexity in terms of numbers of parameters for diversification, but is also independent of the evolution of the focal character, to allow for comparisons among any complex, trait-dependent models of interest.

In Beaulieu and O'Meara (2015), we proposed two such null models. These null models explicitly assume that the evolution of a binary character is independent of the diversification process without forcing the diversification process to be constant across the entire tree, which is the normal null used in these types of analyses. The first model, which we refer to as “null-two”, contains four diversification process parameters that account for trait-dependent diversification solely on the two states of an unobserved, hidden trait. In this way, null-two contains the same amount of complexity in terms of diversification as a BiSSE model. The second model, which we refer to as “null-four” contains the same number of diversification parameters as in the general HiSSE model that are linked across four hidden states. In the case of the "null-four" model, we have implemented a separate function, `hisse.null4()` that should be fairly self-explanatory. However, rather than implementing a separate function for the "null-two" model, it is easier to just set up using the `hisse()` function. This is detailed below.

Now, remember, the goal is to set up a model where the diversification process is independent from the observed states (0 or 1) of the focal trait. In other words, diversification rate differences, if they exist, will only be associated with one of the hidden states (A or B) regardless of the state of the focal trait. To define the free parameters for diversification you would do: 
```{r, eval=TRUE}
turnover.anc = c(1,1,2,2)
eps.anc = c(1,1,2,2)
```
Here, we are specifying that both 0A and 1A have one set of diversification rates, and 0B and 1B have another. That's it. This is the "null-two" model. 

There are three ways in which the transition rates can be set up. The first is to assume the 8 transitions (or 12 if dual transitions are allowed -- for this tutorial we remove dual transitions):
```{r, eval=TRUE}
trans.rates = TransMatMaker(hidden.states=TRUE)
trans.rates.nodual = ParDrop(trans.rates, c(3,5,8,10))
```
We could also assume all rates are equal:
```{r, eval=TRUE}
trans.rates.nodual.allequal = ParEqual(trans.rates.nodual, c(1,2,1,3,1,4,1,5,1,6,1,7,1,8))
trans.rates.nodual.allequal
```
A third option would specify three rates: one rate describing transitions among the different hidden states (which could be intrepreted as the rate by which shifts in diversification occur), and two rates for transitions between the observed character states (0->1 or 1->0). Unfortunately, this requires a little bit of clunky coding:
```{r, eval=TRUE}
# Now we want three specific rates:
trans.rates.nodual.threerates <- trans.rates.nodual
# Set all transitions from 0->1 to be governed by a single rate:
to.change <- cbind(c(1,3), c(2,4))
trans.rates.nodual.threerates[to.change] = 1
# Now set all transitions from 1->0 to be governed by a single rate:
to.change <- cbind(c(2,4), c(1,3))
trans.rates.nodual.threerates[to.change] = 2
# Finally, set all transitions between the hidden state to be a single rate (essentially giving 
# you an estimate of the rate by which shifts in diversification occur:
to.change <- cbind(c(1,3,2,4), c(3,1,4,2))
trans.rates.nodual.threerates[to.change] = 3
trans.rates.nodual.threerates
```
As before, turnover.anc, eps.anc, and trans.rates are supplied as arguments to `hisse()`, and the results can be compared against any model in the hisse set, including BiSSE.

##Plotting hisse reconstructions
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=5)
```
HiSSE also provides plotting functionality for character state reconstructions of `class hisse.states` output by `MarginRecon()` function. There are various ways that these reconstructions can be plotted. First, you can give it a single `hisse.states` object and it will provide a heat map of the diversification rate parameter you specify -- here, you can choose among turnover, net diversification ("net.div""), speciation, extinction, or extinction fraction ("extinction.fraction"). I've provided an example output from the example data set provided above. 
```{r, eval=TRUE}
load("testrecon1.Rsave")
class(pp.recon)
pp.recon
```
This ensures that everything has loaded correctly and that you have a object of the proper `hisse.states` class. One other step that is necessary is to make sure that the `hisse.states` object contains the AIC from the model fit embedded in it. The plotting function will not work without it.
```{r, eval=TRUE}
pp.recon$aic
```
If this returns a NULL, then something has gone wrong and you should check how you performed the reconstructions. If everything is fine, then you can add it manually by simply doing `pp.recon$aic = 364.8615`. But, by default the AIC for the model should be supplied as an argument in the `MarginRecon()` function. 

Now that we have the right files and information, let's plot net diversification rates:
```{r, eval=TRUE}
plot.hisse.states(pp.recon, rate.param="net.div", show.tip.label=FALSE)
```
These are the default colors -- red to blue for rate and white to black for state. However, other colors can be specified (see plot.hisse.states manual). The legend in the bottom left corner provides the frequency of the observed states (0 or 1) at the tips and the distribution of net diversification rates at the tips. Note that in this particular model I only specified two diversification rate parameters (i.e., turnover.anc=c(1,1,1,2), and eps.anc=c(1,1,1,1)), and yet there seems to be a continuous range of rates at the tips. What gives? Well, when a single reconstruction is provided the rates painted on each branch are the weighted average of the rate, weighted by the marginal probability. So the painting takes into account the uncertainty in rates on each branch. 

Please be careful here! Notice that the rates seem like there are parts of the tree that have much higher rates (denoted by bright red) than others (denoted by darker blue)? This is highly misleading, because if you look at the legend the rates span from 0.066 - 0.069! So, really, there aren't any differences in the diversification rates. 

By default the visualization uses the minimum rate on the tree for the minimum color, and the maximum rate for the maximum color, but you may want to use the same color scale across models, even if some of them have a smaller range than others. You can pass a vector with the minimum and maximum rate across all models to the visualization:
```{r, eval=TRUE}
plot.hisse.states(pp.recon, rate.param="net.div", show.tip.label=FALSE, rate.range=c(0,0.072))
```
Now the differences completely disappear.

A really cool feature of the plotting function is that if you provide a list of `hisse.states` objects the function will model-average over the results. In other words, diversification rates are painted such that take into account both state uncertainty and uncertainty in the model. The procedure first calculates a weighted average of the likeliest state and rate combination for every node and tip for each model in the set, using the marginal probability as the weights, which are then averaged across all models using the Akaike weights (i.e., the relative probability of a model). 

I've created two additional `hisse.states` objects that I will use to demonstrate this. I recognize that there are, of course, many ways to generate a list. But here is one way, where I'm assuming that the marginal reconstructions from three models are saved to the directory we are working from:
```{r, eval=TRUE}
# First, suck in all the files with .Rsave line ending
files = system("ls -1 | grep .Rsave", intern=TRUE)
# Create an empty list object
hisse.results.list = list()
# Now loop through all files, adding the embedded pp.recon object in each
for(i in sequence(length(files))){
  load(files[i])
  hisse.results.list[[i]] = pp.recon
  rm(pp.recon)
}
# Now simply supply the list the plotting function
plot.hisse.states(hisse.results.list, rate.param="net.div", show.tip.label=FALSE, rate.range=c(0,0.072))
```
Although this plot is similar to plot above above, which shows no real rate differences, it actually accounts for both the uncertainty in the model as well as the reconstructions. 

##References
Beaulieu, J.M., and B.C. O'Meara. (2015). Detecting hidden diversification shifts in models of trait-dependent speciation and extinction. bioRxiv doi: http://dx.doi.org/10.1101/016386
*Note this is currently accepted pending revision at Systematic Biology

FitzJohn R.G. 2012. Diversitree: comparative phylogenetic analyses of diversification in R. Methods in Ecology and Evolution 3:1084-1092.

